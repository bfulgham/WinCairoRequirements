	; Don't even think of reading this code
	; It was automatically generated by x86cpuid
	; Which is a perl program used to generate the x86 assember for
	; any of ELF, a.out, COFF, Win32, ...
	; eric <eay@cryptsoft.com>
	; 
	TITLE	x86cpuid.asm
        .686
.XMM
IF @Version LT 800
XMMWORD STRUCT 16
	DQ  2 dup (?)
XMMWORD ENDS
ENDIF

.model	FLAT
_TEXT$	SEGMENT PAGE 'CODE'

PUBLIC	_OPENSSL_ia32_cpuid

_OPENSSL_ia32_cpuid PROC NEAR
	push	ebp
	push	ebx
	push	esi
	push	edi
	xor	edx,		edx
	pushfd
	pop	eax
	mov	ecx,		eax
	xor	eax,		2097152
	push	eax
	popfd
	pushfd
	pop	eax
	xor	ecx,		eax
	bt	ecx,		21
	jnc	$L000done
	xor	eax,		eax
	DW	0A20Fh
	xor	eax,		eax
	cmp	ebx,		1970169159
	DB	15,149,192
	mov	ebp,		eax
	cmp	edx,		1231384169
	DB	15,149,192
	or	ebp,		eax
	cmp	ecx,		1818588270
	DB	15,149,192
	or	ebp,		eax
	mov	eax,		1
	DW	0A20Fh
	cmp	ebp,		0
	jne	$L001notP4
	and	eax,		3840
	cmp	eax,		3840
	jne	$L001notP4
	or	edx,		1048576
$L001notP4:
	bt	edx,		28
	jnc	$L000done
	shr	ebx,		16
	and	ebx,		255
	cmp	ebx,		1
	ja	$L000done
	and	edx,		4026531839
$L000done:
	mov	eax,		edx
	mov	edx,		ecx
	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret
_OPENSSL_ia32_cpuid ENDP
EXTRN	_OPENSSL_ia32cap_P:DWORD
PUBLIC	_OPENSSL_rdtsc
EXTRN	_OPENSSL_ia32cap_P:DWORD
_OPENSSL_rdtsc PROC NEAR
	xor	eax,		eax
	xor	edx,		edx
	lea	ecx,		DWORD PTR _OPENSSL_ia32cap_P
	bt	DWORD PTR [ecx],4
	jnc	$L002notsc
	DW	0310Fh
$L002notsc:
	ret
_OPENSSL_rdtsc ENDP
PUBLIC	_OPENSSL_instrument_halt
EXTRN	_OPENSSL_ia32cap_P:DWORD
_OPENSSL_instrument_halt PROC NEAR
	lea	ecx,		DWORD PTR _OPENSSL_ia32cap_P
	bt	DWORD PTR [ecx],4
	jnc	$L003nohalt
	DD	2421723150
	and	eax,		3
	jnz	$L003nohalt
	pushfd
	pop	eax
	bt	eax,		9
	jnc	$L003nohalt
	DW	0310Fh
	push	edx
	push	eax
	hlt
	DW	0310Fh
	sub	eax,		DWORD PTR [esp]
	sbb	edx,		DWORD PTR 4[esp]
	add	esp,		8
	ret
$L003nohalt:
	xor	eax,		eax
	xor	edx,		edx
	ret
_OPENSSL_instrument_halt ENDP
PUBLIC	_OPENSSL_far_spin

_OPENSSL_far_spin PROC NEAR
	pushfd
	pop	eax
	bt	eax,		9
	jnc	$L004nospin
	mov	eax,		DWORD PTR 4[esp]
	mov	ecx,		DWORD PTR 8[esp]
	DD	2430111262
	xor	eax,		eax
	mov	edx,		DWORD PTR [ecx]
	jmp	$L005spin
	ALIGN	16
$L005spin:
	inc	eax
	cmp	edx,		DWORD PTR [ecx]
	je	$L005spin
	DD	529567888
	ret
$L004nospin:
	xor	eax,		eax
	xor	edx,		edx
	ret
_OPENSSL_far_spin ENDP
PUBLIC	_OPENSSL_wipe_cpu
EXTRN	_OPENSSL_ia32cap_P:DWORD
_OPENSSL_wipe_cpu PROC NEAR
	xor	eax,		eax
	xor	edx,		edx
	lea	ecx,		DWORD PTR _OPENSSL_ia32cap_P
	mov	ecx,		DWORD PTR [ecx]
	bt	DWORD PTR [ecx],1
	jnc	$L006no_x87
	bt	DWORD PTR [ecx],26
	jnc	$L007no_sse2
	pxor	xmm0,		xmm0
	pxor	xmm1,		xmm1
	pxor	xmm2,		xmm2
	pxor	xmm3,		xmm3
	pxor	xmm4,		xmm4
	pxor	xmm5,		xmm5
	pxor	xmm6,		xmm6
	pxor	xmm7,		xmm7
$L007no_sse2:
	DD	4007259865,4007259865,4007259865,4007259865,2430851995
$L006no_x87:
	lea	eax,		DWORD PTR 4[esp]
	ret
_OPENSSL_wipe_cpu ENDP
PUBLIC	_OPENSSL_atomic_add

_OPENSSL_atomic_add PROC NEAR
	mov	edx,		DWORD PTR 4[esp]
	mov	ecx,		DWORD PTR 8[esp]
	push	ebx
	nop
	mov	eax,		DWORD PTR [edx]
$L008spin:
	lea	ebx,		DWORD PTR [ecx+eax]
	nop
	DD	447811568
	jne	$L008spin
	mov	eax,		ebx
	pop	ebx
	ret
_OPENSSL_atomic_add ENDP
PUBLIC	_OPENSSL_indirect_call

_OPENSSL_indirect_call PROC NEAR
	push	ebp
	mov	ebp,		esp
	sub	esp,		28
	mov	ecx,		DWORD PTR 12[ebp]
	mov	DWORD PTR [esp],ecx
	mov	edx,		DWORD PTR 16[ebp]
	mov	DWORD PTR 4[esp],edx
	mov	eax,		DWORD PTR 20[ebp]
	mov	DWORD PTR 8[esp],eax
	mov	eax,		DWORD PTR 24[ebp]
	mov	DWORD PTR 12[esp],eax
	mov	eax,		DWORD PTR 28[ebp]
	mov	DWORD PTR 16[esp],eax
	mov	eax,		DWORD PTR 32[ebp]
	mov	DWORD PTR 20[esp],eax
	mov	eax,		DWORD PTR 36[ebp]
	mov	DWORD PTR 24[esp],eax
	call	DWORD PTR 8[ebp]
	mov	esp,		ebp
	pop	ebp
	ret
_OPENSSL_indirect_call ENDP
OPTION	DOTNAME
.CRT$XCU	SEGMENT DWORD PUBLIC 'DATA'
EXTRN	_OPENSSL_cpuid_setup:NEAR
DD	_OPENSSL_cpuid_setup
.CRT$XCU	ENDS
_TEXT$	ENDS
END
